
Broad Phase（粗略筛选）：快速排除不可能碰撞的实体
目标：减少需要精确检测的实体对数量。
推荐算法：网格分区（Grid Partitioning） 或 四叉树（Quadtree），优先选网格分区（实现更简单，适合 2D 游戏）。
网格分区实现：
将游戏地图划分为固定大小的网格（比如每个格子 32×32 像素，根据实体大小调整），每个实体只属于其中心所在的格子。检测时，每个实体只需与自身所在格子和相邻 8 个格子内的实体进行后续精确检测，而非所有实体。
✅ 优势：更新成本低（实体移动时只需判断是否跨格子，更新所属网格即可），适合高频移动的实体（如僵尸、生还者）。
（2）Narrow Phase（精确检测）：判断实体是否真的碰撞
目标：对 Broad Phase 筛选出的实体对，计算是否碰撞。
需选择计算简单、响应平滑的碰撞形状（复杂形状会增加计算量，导致卡顿或抽搐）：
推荐形状：圆形碰撞体（Bounding Circle）
每个实体用一个圆表示（圆心为实体中心，半径为实体碰撞范围，比如生还者半径 10px，僵尸半径 12px）。
检测逻辑：两个实体的圆心距离 ≤ 半径之和 → 发生碰撞。
✅ 优势：计算极快（只需一次距离平方计算，避免开方），碰撞方向明确（沿圆心连线），响应时分离更平滑（不易抽搐）。
替代方案：轴对齐包围盒（AABB）
适合矩形实体（如建筑物），检测逻辑是判断两个矩形在 x、y 轴上的投影是否重叠。
✅ 优势：适合静态障碍物（建筑物），与圆形实体检测时可优化为 “圆与矩形碰撞”。


 碰撞响应：避免 “抽搐” 的关键
“抽搐” 通常是因为碰撞后强制将实体 “弹开” 的幅度太大，或反复触发碰撞检测导致位置抖动。解决方式：
渐进式分离：
检测到重叠时，不一次性将实体移到完全不重叠的位置，而是每帧移动重叠距离的一部分（比如 50%）。例如：两实体重叠 5px，每帧各移 2.5px，2 帧后完全分离，动作更平滑。
速度修正而非位置修正：
对移动中的实体（如僵尸追生还者），检测到碰撞时，不直接调整位置，而是修改移动方向（比如绕开障碍物）。例如：僵尸向生还者移动时撞到建筑物，自动沿建筑物边缘偏移一定角度继续移动



角色碰撞半径设置为 “视觉尺寸的 1.2 倍”（留一点缓冲，避免视觉上已接触但未触发碰撞）；
对建筑碰撞，可进一步优化为 “计算碰撞法线”（如从左侧撞建筑则只能上下移动），响应更自然；


圆形碰撞体（最常用，尤其适合《Run!ZombieFood!》这类游戏）
优势：
碰撞检测计算量极小
圆形碰撞只需计算两个圆心距离（dx² + dy² < (r1+r2)²），无需复杂的矩形边距判断，对大量实体（如你游戏中的多僵尸、多生还者）更友好，性能开销低。
移动更流畅，无 “卡角” 问题
圆形碰撞体在靠近墙角、障碍物边缘时，会自然 “滑过”，不会出现方块碰撞常见的 “卡在 90° 角落无法移动” 的情况。这对需要频繁走位、躲避的游戏（如丧尸围堵场景）至关重要，能显著提升操作手感。
适合 “不规则移动” 的实体
僵尸追逐、生还者逃跑时，移动方向多变，圆形碰撞体的 “各向同性”（任何方向碰撞响应一致）能避免因方向突变导致的卡顿或抽搐。
与视觉表现的适配性
人物模型通常是圆形或近似圆形（从顶视图看，角色身体轮廓更接近圆），圆形碰撞体的 “碰撞范围” 与玩家视觉预期更一致（比如角色边缘接触即触发碰撞）。


平面地图是一个很大的 2维数组。其中比如建筑物是20*20px  方块、 人物和僵尸是半径为2 的圆 映射在平面上 是这意思吗


1. 位集（BitSet/BitArray）：极致压缩内存（推荐）
原理：用 1 个二进制位（bit）存储 1 个像素的状态（0 = 可行走，1 = 不可行走），8 个像素仅占 1 字节，比二维数组节省 8 倍内存。
适用场景：只需要二值判断（可走 / 不可走），且地图固定不变。
优势：
内存占用极低：10000×10000 仅需约 12MB（10⁸bit = 12,500,000 字节）；
查询速度快（接近数组），支持批量位运算（如快速判断某区域是否全为可走）。




一、明确两类碰撞的定义和范围
1. 静态碰撞检测（Static Collision）
定义：动态实体（人物 / 僵尸）与静态环境（建筑 / 地形）之间的碰撞。
核心特点：
静态环境（建筑）的位置和形状固定不变（加载后不移动）；
检测频率高（每个动态实体每帧都需要检测）；
是 “单向检测”（只需判断动态实体是否撞上静态环境，无需反过来检测）。
你的游戏场景举例：
生还者撞到墙壁 / 房屋；
僵尸试图穿过不可行走的建筑区域。
2. 动态碰撞检测（Dynamic Collision）
定义：动态实体之间的碰撞（人物↔人物、人物↔僵尸、僵尸↔僵尸）。
核心特点：
双方都是移动的（位置每帧可能变化）；
检测对象是 “动态实体集合”，数量可能很多（如 100 + 僵尸）；
是 “双向检测”（A 撞 B 和 B 撞 A 是同一事件，需避免重复计算）。
你的游戏场景举例：
两个生还者挤在一起（需避免重叠）；
僵尸群互相拥挤（需保持间距）；
僵尸碰到生还者（触发攻击 / 追逐逻辑）。
二、两类检测的技术差异（为什么要分开处理？）
维度	静态碰撞检测（动态→静态）	动态碰撞检测（动态→动态）
检测对象	单个动态实体 vs 整个静态环境	动态实体集合中 “两两成对” 检测
优化方向	利用静态环境的 “固定性” 做预处理（如可行走数组、位集）	减少 “无效检测对”（如用网格分区过滤不相邻的实体）
响应逻辑	阻止动态实体穿透（如推回实体、改变移动方向）	双方分离或互动（如各退一半距离、触发战斗逻辑）
性能敏感度	与动态实体数量成正比（O (n)）	与动态实体数量的平方成正比（O (n²)，需重点优化）
