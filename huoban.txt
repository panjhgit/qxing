基于 Canvas 的抖音小游戏 “领航者 - 跟随者” 设计方案
（适配移动端触摸交互、轻量流畅、无复杂引擎依赖）
一、基础框架设计：核心逻辑与环境适配
1. Canvas 环境适配原则
屏幕缩放：以抖音生态常用的「750px 设计宽度」为基准，按手机实际宽度等比缩放（例：手机宽度 375px 则缩放 0.5 倍），避免拉伸变形；
高清屏处理：通过devicePixelRatio优化渲染精度，防止 Canvas 模糊（尤其 OLED 屏幕）；
触摸区域划分：固定「左下角 150×150px 区域」为摇杆交互区，避免与其他 UI（如技能按钮、血量条）冲突。
2. 角色状态体系（统一状态机）
角色类型	核心状态	状态切换触发条件
主人物（领航者）	Idle（待机）	摇杆无输入、无僵尸可攻击
Move（移动）	摇杆有输入（触摸偏移超过死区）
Attack（攻击）	摇杆无输入 + 周围有可攻击僵尸
伙伴（跟随者）	Idle（待机）	主人物 Idle 且无僵尸、无拥堵
Follow（跟随）	主人物 Move 或 Attack 结束后
Attack（攻击）	主人物 Attack + 自身范围内有可攻击僵尸
Avoid（避障）	检测到主人物被自己堵住（满足拥堵条件）
3. 数据同步规则（低延迟交互关键）
同步内容：主人物实时位置、移动方向、摇杆输入状态（有 / 无输入），每帧更新 1 次；
同步方式：伙伴直接读取主人物的公开属性（无需复杂通信），保证 0 延迟（Canvas 单线程环境天然支持）；
异常处理：若主人物因碰撞卡住，同步 “停滞状态” 给伙伴，伙伴暂停跟随并保持安全距离。
二、模块 1：主人物（领航者）控制设计
1. 摇杆交互逻辑
交互环节	设计细节
触摸触发	仅在左下角摇杆区（x：50~200px，y：Canvas 高 - 200~Canvas 高 - 50px）触发触摸响应；
死区过滤	触摸偏移距离＜5px（死区阈值）时，视为 “无输入”，避免手指微小抖动导致误移动；
方向计算	以触摸起始点为原点，计算偏移向量并归一化（例：右移偏移 (30,0)→方向 (1,0)），确保不同偏移距离移动速度一致；
输入中断	手指离开屏幕 / 移出摇杆区时，立即清零输入方向，主人物切换为 Idle 状态。
2. 主人物行为规则
移动约束：
边界限制：不能移出 Canvas 可视范围（主人物中心到边缘距离≥自身半径，避免 “半个身体出屏”）；
速度控制：固定移动速度 5px / 帧（适配抖音小游戏 60fps，实际移动速度 300px / 秒，符合移动端操作直觉）；
朝向同步：移动方向即主人物朝向（例：摇杆向左→主人物朝左，渲染时用 “小线段” 标记朝向）。
攻击触发：
无摇杆输入时，自动检测 “以主人物为中心、半径 200px” 范围内的僵尸，有可攻击目标则切换为 Attack 状态。
三、模块 2：伙伴（跟随者）跟随设计
1. 跟随目标点计算（避免僵硬贴脸）
基础逻辑：不直接跟随主人物位置，而是在主人物侧后方生成跟随点（天然减少堵路）；
2D 场景计算公式：
plaintext
跟随点X = 主人物X - 主人物朝向X × 120px（前后距离） + 主人物朝向Y × 60px（左右偏移）
跟随点Y = 主人物Y - 主人物朝向Y × 120px（前后距离） - 主人物朝向X × 60px（左右偏移）

（例：主人物朝右→跟随点在主人物左后方，朝左→跟随点在主人物右后方）；
动态调整：主人物转向时，跟随点实时更新（每帧重新计算），避免伙伴 “绕圈追”。
2. 距离与路径控制
控制维度	设计规则
跟随半径	伙伴到跟随点距离＞150px 时，以 4.5px / 帧（比主人物慢 0.5px）加速追赶；
停止半径	伙伴到跟随点距离＜30px 时，停止移动（避免在主人物身边 “来回晃”）；
路径规划（避障）	1. 直线检测：用 “Canvas 射线法”（从伙伴到跟随点画虚拟线段），检测是否穿过障碍物；
偏移策略：若直线有障碍，向主人物朝向的垂直方向偏移 50px，重新检测，直到找到通路（最多偏移 3 次，避免死循环）。 |
四、模块 3：自动协同攻击设计
1. 攻击触发三条件（必须同时满足）
主人物无输入：摇杆触摸偏移≤死区（确保玩家 “想打怪” 而非 “想移动”）；
僵尸在检测范围：主人物 200px 范围内、伙伴 150px 范围内有僵尸；
僵尸可攻击：僵尸处于 “存活状态”（血量＞0）且 “非无敌”（无护盾等 buff）。
2. 目标分配与攻击逻辑
目标选择优先级：
主人物→优先攻击 “离主人物最近的僵尸”；
伙伴→优先攻击 “离伙伴最近且主人物未攻击的僵尸”（避免扎堆打一个）；
攻击行为规则：
移动到攻击距离：主人物攻击距离 80px、伙伴攻击距离 70px（靠近目标到距离≤攻击距离才触发攻击）；
攻击 CD：固定 15 帧（0.25 秒），避免 “连打” 导致动画 / 逻辑卡顿；
状态回切：僵尸死亡 / 超出范围时，伙伴立即切回 Follow 状态，跟随主人物。
五、模块 4：拥堵让路设计（核心难点解决）
1. 拥堵检测条件（避免误判）
需同时满足以下 2 个条件，才判定为 “主人物被伙伴堵住”：
方向条件：主人物移动方向朝向伙伴（主人物到伙伴的方向向量，与主人物移动方向夹角＜30°）；
距离条件：主人物与伙伴的距离＜80px（小于攻击距离，即将碰撞）。
2. 两种避障策略（适配不同场景）
策略类型	适用场景	执行逻辑
主动让路（侧移）	主人物前方被伙伴挡住，且伙伴侧面有空间	1. 计算避让方向：垂直于主人物移动方向（例：主人物朝前→伙伴向左 / 右移）；
移动距离：向避让方向移动 80px（足够主人物通过）；
暂停等待：直到主人物通过伙伴原位置，切回 Follow 状态。 |
| 先走开路（前移） | 主人物要去的方向被伙伴挡住，且伙伴前方无障 | 1. 计算开路点：在主人物移动方向上，伙伴前方 120px 处；
伙伴移动到开路点，暂停等待；
主人物到达伙伴原位置后，伙伴切回 Follow 状态。 |
3. 避障优化（提升智能感）
空间检测：避障前用 “射线法” 检测目标方向是否有障碍物（例：想左移时检测左侧 50px 是否有墙），有障碍则切换方向；
多伙伴适配：若有多个伙伴，优先让 “离主人物最近的伙伴” 避障，其他伙伴保持原跟随点，避免 “全挤在一起让” 导致新拥堵。
六、整体帧流程设计（确保逻辑连贯）
每帧按以下顺序执行（适配 Canvas 60fps，无卡顿）：
输入读取：获取摇杆触摸状态（有 / 无输入、移动方向）；
主人物更新：根据输入切换状态（Move/Idle），处理移动与边界检测；
伙伴决策：
若主人物 Move→伙伴 Follow（计算跟随点 + 避障移动）；
若主人物 Idle→检测是否有僵尸→有则 Attack，无则检测是否拥堵→拥堵则 Avoid；
攻击检测：主人物与伙伴分别判断是否满足攻击条件，触发攻击行为；
渲染更新：清空 Canvas，依次渲染地图→障碍物→主人物→伙伴→僵尸→UI（摇杆、血量等）。
七、调试与优化要点
参数可配置：将移动速度、跟随半径、攻击范围等参数抽为全局变量，方便快速调试（例：伙伴跟随太慢则调快速度）；
可视化调试：开发阶段用 “虚线” 渲染跟随点、攻击范围、拥堵检测区域，直观判断逻辑是否正常；
性能优化：
减少每帧计算量：障碍物检测只查 “伙伴周围 200px” 范围内的障碍，而非全地图；
简化碰撞形状：主人物 / 伙伴 / 僵尸均用圆形碰撞（计算量远小于矩形）。