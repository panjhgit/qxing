一、核心性能指标（硬性要求）
指标	目标值	说明
内存占用	常规场景≤50MB，极端场景≤60MB	包含所有资源（纹理、音频、对象数据），通过 tt.getSystemInfoSync().memory 监控。超过 60MB 易触发 GC 卡顿或闪退。
帧率稳定性	稳定 30FPS 以上，波动≤5FPS	抖音小游戏主流设备的舒适帧率，通过 requestAnimationFrame 计算（每帧耗时≤33ms）。波动过大会导致画面跳动。
单帧耗时	逻辑计算≤15ms，渲染绘制≤10ms	单帧总耗时 = 逻辑（AI / 碰撞）+ 渲染（绘制），超过 33ms 会掉帧。需通过性能埋点拆分各模块耗时（如僵尸 AI 占 8ms）。
GC 频率	每分钟≤3 次，单次 GC 耗时≤5ms	频繁 GC（如每分钟＞5 次）会导致卡顿，需通过对象池复用、避免临时变量创建减少 GC 触发（可用 tt.getPerformance() 监控）。
资源加载耗时	初始加载≤3 秒，场景切换≤1.5 秒	超过 5 秒会导致用户流失，需通过子包加载、资源预加载、低清资源降级优化（结合 tt.loadSubpackage 异步加载）。

可使用 Terser 等工具移除调试信息

一、实体管理与更新策略
1. 僵尸群体动态调控
数量阈值控制：设置动态上限（基础值 80-100，根据设备性能自动下调），超出上限时优先销毁距离玩家最远的僵尸
活性范围机制：仅激活玩家周围 1200px 范围内的僵尸，超出范围的僵尸进入 "休眠状态"（停止 AI 计算和渲染）
分帧更新策略：将所有活跃僵尸分成 5-8 个批次，每帧仅更新 1 个批次的 AI 逻辑，避免单帧计算压力过载
优先级调度：距离玩家 500px 内的僵尸每帧更新，500-800px 每 2 帧更新，800px 外每 3 帧更新
2. 伙伴协同轻量化
跟随目标简化：采用 "预测式跟随点"（基于玩家移动方向提前 100ms 计算跟随位置），减少实时路径计算
行为优先级排序：移动指令＞攻击指令＞避障指令，确保玩家操作响应无延迟
多伙伴分组处理：超过 3 个伙伴时，按距离玩家远近分组，优先更新最近的 2-3 个伙伴逻辑
二、渲染系统优化
1. 视距裁剪与分层渲染
视口可见性过滤：仅渲染当前屏幕范围内（加 100px 缓冲区）的实体，屏幕外实体完全不绘制
三层 Canvas 架构：
底层：静态背景（仅初始绘制 1 次，滚动时平移而非重绘）
中层：动态实体（僵尸、伙伴、玩家）
顶层：UI 元素（血条、摇杆、菜单）
脏矩形更新：仅重绘发生变化的区域（如移动的实体、消失的僵尸），减少全屏清空重绘
2. 图形资源优化
精灵图集整合：将所有角色、僵尸、道具的静态帧 / 动画帧合并为 1-2 张精灵图集，减少图片切换开销
LOD（细节层次）策略：
近距离（＜300px）：显示完整动画帧 + 细节纹理
中距离（300-600px）：简化动画帧（每 2 帧合并 1 帧）
远距离（＞600px）：使用单色剪影或低多边形图形替代
三、碰撞检测与物理优化
1. 空间分区管理
四叉树动态划分：根据实体密度自动调整树深度（密集区域细分，稀疏区域粗分），单次查询复杂度从 O (n) 降至 O (log n)
静态碰撞预处理：将地图障碍物（建筑、地形）转换为二进制网格（1bit 表示可走 / 不可走），内存占用低且查询速度快
动态碰撞过滤：通过四叉树先筛选出潜在碰撞对（距离＜100px），再进行精确碰撞计算，减少 90% 无效检测
2. 碰撞响应简化
静态碰撞快速处理：采用 "推回法"（碰撞后直接将实体推离障碍物最小距离），避免复杂物理计算
动态碰撞分组处理：僵尸之间碰撞仅做简单分离（各退 50% 重叠距离），玩家与伙伴碰撞优先保证玩家移动路径
四、游戏循环与资源调度
1. 帧率自适应机制
动态帧率锁定：根据设备性能自动选择 30FPS（低端机）或 60FPS（高端机），避免过度渲染
计算任务拆分：将复杂逻辑（如批量僵尸生成、地图刷新）拆分为多帧执行，单帧耗时控制在 16ms（60FPS）或 33ms（30FPS）内
优先级队列：输入响应＞玩家状态更新＞伙伴逻辑＞僵尸 AI＞UI 动画，确保操作无延迟
2. 资源生命周期管理
对象池复用：僵尸、特效等高频创建 / 销毁的实体采用对象池管理，初始化时创建 20 个备用实例，避免 GC（垃圾回收）卡顿
按需加载：进入新场景时只加载当前区域所需资源（如特定僵尸类型、地形纹理），离开后立即释放
内存阈值监控：当内存占用超过 80MB 时，自动释放远处实体的纹理资源（保留位置信息，进入视野时重新加载）
五、AI 与逻辑优化
1. 行为决策简化
状态机精简：僵尸状态从 5 种（Idle/Wander/Chase/Attack/Die）简化为 3 种（Idle/Chase/Attack），合并相似状态逻辑
路径缓存：僵尸寻路结果缓存 300ms，期间重复路径不重新计算；玩家移动方向不变时，伙伴跟随路径复用前帧结果
目标选择优化：采用 "最近目标优先" 算法（基于四叉树查询结果），避免遍历所有实体寻找目标
2. 交互逻辑轻量化
攻击判定简化：用圆形碰撞替代多边形碰撞（攻击范围 = 实体半径 + 攻击距离），计算量减少 60%
动画与逻辑解耦：动画播放不阻塞游戏逻辑（如攻击动画播放时，伤害判定提前 1 帧完成）
状态切换延迟：非关键状态切换（如 Idle→Wander）延迟 1-2 帧执行，优先保证玩家操作响应
六、测试与监控体系
性能指标埋点：实时监控帧率、单帧耗时、实体数量、内存占用，在调试模式下可视化展示
设备分级适配：根据设备 GPU/CPU 性能自动调整参数（如低端机僵尸上限降至 50，关闭 LOD 近距离细节）
极限场景测试：模拟 100 + 僵尸同时攻击、多伙伴协同、复杂地形碰撞等场景，确保帧率稳定在 25FPS 以上
通过以上策略，可在保证核心玩法完整的前提下，将 CPU 占用降低 40%-60%，内存占用控制在 80MB 以内，实现全设备流畅运行（包括中低端安卓机）。优化核心思路是 "空间换时间"（如缓存、预计算）和 "优先级取舍"（确保玩家操作响应优先于非关键逻辑）。