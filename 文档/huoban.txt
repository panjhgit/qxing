基于 Canvas 的抖音小游戏 “领航者 - 跟随者” 设计方案

一、基础框架设计：核心逻辑与环境适配
1. Canvas 环境适配原则

2. 角色状态体系（统一状态机）
角色类型	核心状态	状态切换触发条件

主人物（领航者）
Idle（待机）	无操作、无移动意图	摇杆无输入 + (50px内)无僵尸可攻击,静止不动，渲染待机动画 ,如果50px 内有僵尸则主动追击僵尸进行战斗
Move（移动）	玩家控制移动（含移动中遇僵尸）	摇杆有输入（触摸偏移超死区）→ 无论周围是否有僵尸
1. 按摇杆方向移动（优先执行）；
2. 若周围有僵尸，仅 “视觉提示”（如僵尸高亮），不主动攻击,但是不影响僵尸攻击人物；
3. 移动中如果对僵尸攻击播放攻击动画。
Attack（攻击）
玩家无操作，僵尸在人物50px范围内人物自动攻击僵尸,摇杆无输入 ,（优先级低于 Move）
1. 移动到攻击距离；
2. 触发攻击动画 + 伤害判定；
3. 无僵尸则切 Idle。



伙伴（跟随者）
Idle（待机）	主人物无操作、无移动、无僵尸	主人物 Idle + 无僵尸 + 无拥堵	 如果指定范围内有僵尸,主动靠近僵尸并且攻击，范围内无僵尸则渲染待机动画
Follow（跟随）
跟随主人物移动（含主人物移动中遇僵尸）
1. 主人物 Move（无论周围是否有僵尸）；
2. 主人物 Attack 结束且无僵尸；
3. 避障（Avoid）结束后
1. 优先按 “跟随规则” 追主人物的跟随点（移动优先级最高）；
2. 若周围有僵尸，仅 “朝向僵尸”，一定范围内主动靠近僵尸并且攻击；
3. 移动中同步避开障碍物和主人物。

Attack（攻击）	主人物无操作且自身可攻击僵尸	主人物 Attack + 自身范围内有可攻击僵尸（优先级低于 Follow）
1. 移动到自身攻击距离；
2. 触发攻击动画（与主人物攻击节奏错开，避免同步卡顿）；
3. 主人物恢复移动时，立即停止攻击切 Follow。
Avoid（避障）	主人物被自己堵住	满足拥堵检测条件（无论周围是否有僵尸）	按避障策略执行（侧移 / 前移），避障结束后：
1. 若主人物仍在 Move→切 Follow；
2. 若主人物已 Idle 且有僵尸→切 Attack。
三、关键状态过渡逻辑（避免行为混乱）
重点定义 “移动中遇僵尸” 时的状态切换规则，确保玩家操作与自动行为无缝衔接：
场景（玩家操作）	主人物状态过渡	伙伴状态过渡	核心逻辑（玩家主导）
1. 周围有僵尸，玩家操作摇杆移动	Attack/Idle → Move（立即切换）	Attack → Follow（立即切换）	玩家想移动时，无论是否在打怪，立即停止攻击，优先跟随玩家移动
2. 移动中遇僵尸，玩家松开摇杆	Move → Attack（若有僵尸）/Idle（无僵尸）	Follow → Attack（若主人物 Attack）/Idle	玩家停止移动后，才触发自动攻击，避免 “移动中突然停住打怪”
3. 攻击中，玩家突然操作摇杆	Attack → Move（打断攻击 CD）	Attack → Follow（打断攻击）	玩家操作优先级最高，即使在攻击动画中，也立即停止并跟随移动
4. 移动中遇僵尸 + 拥堵	Move（保持）	Follow → Avoid（先避障，再跟随）	先解决 “堵路” 问题（伙伴避障），再继续跟随主人物移动，不插入攻击行为




3. 数据同步规则（低延迟交互关键）
同步内容：主人物实时位置、移动方向、摇杆输入状态（有 / 无输入），每帧更新 1 次；
同步方式：伙伴直接读取主人物的公开属性（无需复杂通信），保证 0 延迟（Canvas 单线程环境天然支持）；
异常处理：若主人物因碰撞卡住，同步 “停滞状态” 给伙伴，伙伴暂停跟随并保持安全距离。
二、模块 1：主人物（领航者）控制设计
1. 摇杆交互逻辑
交互环节	设计细节
触摸触发	仅在左下角摇杆区（x：50~200px，y：Canvas 高 - 200~Canvas 高 - 50px）触发触摸响应；
死区过滤	触摸偏移距离＜5px（死区阈值）时，视为 “无输入”，避免手指微小抖动导致误移动；
方向计算	以触摸起始点为原点，计算偏移向量并归一化（例：右移偏移 (30,0)→方向 (1,0)），确保不同偏移距离移动速度一致；
输入中断	手指离开屏幕 / 移出摇杆区时，立即清零输入方向，主人物切换为 Idle 状态。
2. 主人物行为规则
移动约束：
边界限制：不能移出 Canvas 可视范围（主人物中心到边缘距离≥自身半径，避免 “半个身体出屏”）；
速度控制：固定移动速度 5px / 帧（适配抖音小游戏 60fps，实际移动速度 300px / 秒，符合移动端操作直觉）；
朝向同步：移动方向即主人物朝向（例：摇杆向左→主人物朝左，渲染时用 “小线段” 标记朝向）。
攻击触发：
无摇杆输入时，自动检测 “以主人物为中心、半径 200px” 范围内的僵尸，有可攻击目标则切换为 Attack 状态。
三、模块 2：伙伴（跟随者）跟随设计
1. 跟随目标点计算（避免僵硬贴脸）
基础逻辑：不直接跟随主人物位置，而是在主人物侧后方生成跟随点（天然减少堵路）；
2D 场景计算公式：
plaintext
跟随点X = 主人物X - 主人物朝向X × 120px（前后距离） + 主人物朝向Y × 60px（左右偏移）
跟随点Y = 主人物Y - 主人物朝向Y × 120px（前后距离） - 主人物朝向X × 60px（左右偏移）

（例：主人物朝右→跟随点在主人物左后方，朝左→跟随点在主人物右后方）；
动态调整：主人物转向时，跟随点实时更新（每帧重新计算），避免伙伴 “绕圈追”。
2. 距离与路径控制
控制维度	设计规则
跟随半径	伙伴到跟随点距离＞150px 时，以 4.5px / 帧（比主人物慢 0.5px）加速追赶；
停止半径	伙伴到跟随点距离＜30px 时，停止移动（避免在主人物身边 “来回晃”）；
路径规划（避障）	1. 直线检测：用 “Canvas 射线法”（从伙伴到跟随点画虚拟线段），检测是否穿过障碍物；
偏移策略：若直线有障碍，向主人物朝向的垂直方向偏移 50px，重新检测，直到找到通路（最多偏移 3 次，避免死循环）。 |
四、模块 3：自动协同攻击设计
1. 攻击触发三条件（必须同时满足）
主人物无输入：摇杆触摸偏移≤死区（确保玩家 “想打怪” 而非 “想移动”）；
僵尸在检测范围：主人物 200px 范围内、伙伴 150px 范围内有僵尸；
僵尸可攻击：僵尸处于 “存活状态”（血量＞0）且 “非无敌”（无护盾等 buff）。
2. 目标分配与攻击逻辑
目标选择优先级：
主人物→优先攻击 “离主人物最近的僵尸”；
伙伴→优先攻击 “离伙伴最近且主人物未攻击的僵尸”（避免扎堆打一个）；
攻击行为规则：
移动到攻击距离：主人物攻击距离 80px、伙伴攻击距离 70px（靠近目标到距离≤攻击距离才触发攻击）；
攻击 CD：固定 15 帧（0.25 秒），避免 “连打” 导致动画 / 逻辑卡顿；
状态回切：僵尸死亡 / 超出范围时，伙伴立即切回 Follow 状态，跟随主人物。
五、模块 4：拥堵让路设计（核心难点解决）
1. 拥堵检测条件（避免误判）
需同时满足以下 2 个条件，才判定为 “主人物被伙伴堵住”：
方向条件：主人物移动方向朝向伙伴（主人物到伙伴的方向向量，与主人物移动方向夹角＜30°）；
距离条件：主人物与伙伴的距离＜80px（小于攻击距离，即将碰撞）。
2. 两种避障策略（适配不同场景）
策略类型	适用场景	执行逻辑
主动让路（侧移）	主人物前方被伙伴挡住，且伙伴侧面有空间	1. 计算避让方向：垂直于主人物移动方向（例：主人物朝前→伙伴向左 / 右移）；
移动距离：向避让方向移动 80px（足够主人物通过）；
暂停等待：直到主人物通过伙伴原位置，切回 Follow 状态。 |
| 先走开路（前移） | 主人物要去的方向被伙伴挡住，且伙伴前方无障 | 1. 计算开路点：在主人物移动方向上，伙伴前方 120px 处；
伙伴移动到开路点，暂停等待；
主人物到达伙伴原位置后，伙伴切回 Follow 状态。 |
3. 避障优化（提升智能感）
空间检测：避障前用 “射线法” 检测目标方向是否有障碍物（例：想左移时检测左侧 50px 是否有墙），有障碍则切换方向；
多伙伴适配：若有多个伙伴，优先让 “离主人物最近的伙伴” 避障，其他伙伴保持原跟随点，避免 “全挤在一起让” 导致新拥堵。
六、整体帧流程设计（确保逻辑连贯）
每帧按以下顺序执行（适配 Canvas 60fps，无卡顿）：
输入读取：获取摇杆触摸状态（有 / 无输入、移动方向）；
主人物更新：根据输入切换状态（Move/Idle），处理移动与边界检测；
伙伴决策：
若主人物 Move→伙伴 Follow（计算跟随点 + 避障移动）；
若主人物 Idle→检测是否有僵尸→有则 Attack，无则检测是否拥堵→拥堵则 Avoid；
攻击检测：主人物与伙伴分别判断是否满足攻击条件，触发攻击行为；
渲染更新：清空 Canvas，依次渲染地图→障碍物→主人物→伙伴→僵尸→UI（摇杆、血量等）。
七、调试与优化要点
参数可配置：将移动速度、跟随半径、攻击范围等参数抽为全局变量，方便快速调试（例：伙伴跟随太慢则调快速度）；
可视化调试：开发阶段用 “虚线” 渲染跟随点、攻击范围、拥堵检测区域，直观判断逻辑是否正常；
性能优化：
减少每帧计算量：障碍物检测只查 “伙伴周围 200px” 范围内的障碍，而非全地图；
简化碰撞形状：主人物 / 伙伴 / 僵尸均用圆形碰撞（计算量远小于矩形）。